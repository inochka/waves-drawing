6 лабораторная

Про 5 лабу. Загадочная фраза - не использоватеть асс вставку в распараллеливании.
В чем дело?
есть процессор и сопроцессор
и они работают совсем параддельно, если нет обмена данными. И процессор обрабаьтывает инты,
а сопроцоссор - флоаты. Поэтому нужно планировать код так, чтобы опреации примерно равномерно распределялись между процессором и сопроцессором, поэтому в той же задаче на сложение элементов массива выкогдно складывать элементы пачками (где-то на 4-5 элементах обычно оптимум работы процессора и сопроцессора), то есть наша задача - помочь компьютеру распараллелить операции между процессором и сопроцессором.

ЦП побще не можкт работать с флоатами, а смотрит на них только как на последовательность нулей и единиц. Он может их сдвинуть, посчитать, что в CF упало, но складывать/умножать их - нет.

Какие вообще есть сопроцессоры? Сейчас сопроцессор физически никак от процессора не отделен (хоя раньше это было так). Есть отдельный сопроцессор для вычисления флоатов, отдельный - для быстрого вычисления адресов, звуковая карта - тоже со своим сопроцессором и

Почему беск цикл в лабе 5? А потому, что счетчик начинает сбиваться в неко момент.


Руководство пользователя.

1. Цель - запрограммировать и просчитать какую-нибудь линейную простую модельку (мб даже одномерную). По умолчанию - 3 варианта:

    1) Банальная термодинамика. Есть некоторый ограниченный объем с кучей (1000000...) точек, взаимодействующих только в процессе столкновений, набор начальных условий (мб градиент температуры :) ), и строить T(x, t). Проще визуализировать для отлкадки. Главнрое - получить одномерные графики, которые можно анализировать. (разбивать на участки). Плюс, задай поперечное сечение! (если только точность флоата - слишком редкие столкновения)
    Ассемблер мб понадобиться (несколько строк), если будет 100000 точек, а не 100.

    2) Одномерная цепочка из шариков и пружинок (концы закрепленные/__свободные__), скорость - направлена как укодно, не обязательно вдоль цепочки, посмотреть распределение сокростей и "бег" волн. Можно с разрушением, можно без.
    Пример - аэростатная защита от самолетов (ниточка перерезает крыло, работало, пока самолеты летали низко. В квазистатическом приближении получается, что ниточка не перережется, и необходимо учитывать конечность скорости распространения возмущений по ыепочке. В этом случае сила натяжения нити оказывается достаточной для перерезаняи крыла самолета).
    Начни с одномерноц задлачи! не берись за сложную сразу! Использую такой же подход, как на белорусских олимпиадах.
    Одномерные графики - зависимость скорости от точки в конкретный момент времени.
    По времени - не парься, обычно в физическом моделировании модельное время сильно != реальному. Эту лабу лучше оформить, чтобы не запутаться самому и не запутать беклемышеву.

    3) 3 задача - ультразвук. Не совсем одномерная. Есть какая-то среда (исследуем). К верхнему краю прижат сенсор. Если сенсоров много, можем реализовать нечтно вроде бинокулярного времени (смотреть задержку между приходом сигналов к различным элементам), и строим графики. Затем срабытывает новый источник, и т. д. И у нас получается какое-то количество таких вот картинок. Из них хотим получить картинку.



Алгоритм моей задачи:
1) вводим полярную систему координат
разбиваем ее на сектора
"фокусируем" волну на каждом секторе
делаем некоторый фиксированный радиус и фокусируемся на нем
если попадаем в один сектор с источником, фиксируем это в лог
и обходим таким образом все секторы

То есть... мы детектором пускаем лучи (реально - с определенной задержкой, чтобы их сфокусировать)
Они как-то отражаются (напиши функцию отражения, с учетом сектора!)
И мы их снова принимаем
и видим задержку на каждый детектор (по времени прихода и времени отправления)
ага! вот и наша струтура линии понадобится теперь!
мы знаем угол, но не знаем расстояния! вот! и расстояние - как раз через временную задержку!
то есть... высылаем с задержкой, настраивая на определенное расстояние от источника, и смотрим, было ли отражение!!!! То есть... Да! прибавляем задержку, равную исходной, к времени и сравниваем с погрешностью, определенной размером зоны!!!
(ведь отражение и от другой зоны вполне могло себе произойти!)
точно! именно так! да! и мы при отражении меняем фазу и "ориентацию!" поэтому мы смотрим на "ориентированные" лучи (или чтобы все были ориентированы, этого достаточно?) Нет! иначе смысла в задержке не было бы!Звук!- не свет, а волна, помни! то есть надо, по реальному, делать волну от каждого детектора с определенной задержкой, а не лучи! Иначе - нереальная, а потому слишком простая задача. Чтобы в результате интерференции усиеление было на рассматриваемом секторе.
ААА!и результирующая волна - то же самое, как если бы излучал источник, в этом и фишка идеи с фокусировкой и отражением. и по ней находим времена прибытия и сравниваем их с исходными задержками?
