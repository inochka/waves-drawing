#ifndef __GRAPH_C__

#define __GRAPH_C__


#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "types.h"
#include "constants.h"
#include "prototypes.h"
#include <allegro5/allegro.h>
#include <allegro5/allegro_native_dialog.h>
#include <allegro5/allegro_primitives.h>


int draw_wave(ALLEGRO_DISPLAY * display, wave * w){
    if(display == NULL || w == NULL){
        fprintf(stderr, "Невозможно отрисовать несуществующую волну или поле не существует!\n");
        exit(1);
    }

    int color = 250 / w->ampl * MIN_AMPL;

    ALLEGRO_COLOR wave_color = al_map_rgb(color, color, color);

    if(w->n_x >= 0)
        al_draw_pieslice(w->center_x, w->center_y, w->r, atan(w->n_y / w->n_x) - PI / 2, PI, wave_color, 1);
    else
        al_draw_pieslice(w->center_x, w->center_y, w->r, - atan(- w->n_y / w->n_x) + PI / 2, PI, wave_color, 1);


    return 0;
}




// а эта функция будет просчитывать все волны с заданным шагом во времени
// не совсем то же самое, что последующая
// идеологически правильнее ее именно здесь разместить

int move_time(QUEUE * ws, sources * ss, double t, ALLEGRO_DISPLAY * display, int num, field * f, detector * d){

    // num - число волн на даннй момент

    // начинаем с инициализации графики, таймеров и очереди событий

    ALLEGRO_EVENT_QUEUE * event_queue = NULL;
    ALLEGRO_TIMER *timer = NULL;
    bool redraw = true;

    timer = al_create_timer(REDRAW_TIME);
    if(!timer) {
        fprintf(stderr, "Ошибка при создании таймера!\n");
        al_destroy_display(display);
        return -1;
    }


    event_queue = al_create_event_queue();

    if(!event_queue) {
        fprintf(stderr, "Ошибка при создании очереди событий!\n");
        al_destroy_display(display);
        al_destroy_timer(timer);
        return -1;
    }

    // привязываем таймер и окно к очереди событий как источники событий

    al_register_event_source(event_queue, al_get_display_event_source(display));
    al_register_event_source(event_queue, al_get_timer_event_source(timer));

    // то есть таймер просто с заданным интервалом добавляет событие в очередь событий
    // ага! то есть в сущности-то таймер нам и не нужен в таком виде, поскольку нам нужно отрисовывать не через фиксированные промежутки времени, а тогда, когда просчитаются необходимые волны. + мб с некоторой задержкой для наглядности
    // ааа! то есть он нам понадобится, но нужно будет в йункции расчета волн смотреть, что произошло раньше: таймер сработал или волны для данного момента времени просчитались! отлично! понятно теперь.


    // все! артподготовка сделана! осталось просто расчитать волны.


    if(is_empty_queue(ws) == 1 || num < 1){
        fprintf(stderr, "Нет волн для подсчета!\n");
        exit(1);
    }

    // то есть главное, что она булет изменять - наш массив волн
    int i, j, delta_num;

    double x, y, scal;
    // координаты рассматриваемой точки волнового фронта

    wave * w;
    source * s;

    // задаем шаш в пространстве. Через него определим эффективный размер источника выше

    double r_step = (double)(SPEED * TIME_STEP);

    double exp_attenuation = exp(- ATTENUATION * r_step);
    // все, что можем вычислить только 1 раз, сразу вычисляем


    // то есть решили реализовывать очередь, последовательно все пересчитывая, либо сразу данную волну в конец очерели кидаем, если ни с чем не взаимодейтсвует, либо отражаем, создаем еще (и учитываем, что старая продолжает распространяться!) и помещаем их все в конец очереди в произволтном порядке!
    // точно! вот идеальное решение! вообще, так оно обычно и реализовывается, когда кучу всего пересчитывать надо. И в ОС также, кст, ресурсы между процессами распределяются

    // все! начинаем таймер!

   al_start_timer(timer);

   ALLEGRO_EVENT event;
   // переменная для хранения события

    while(1){
        // цикл по времени
        // вначале все просчитываем, а затем смотрим, не прошло ли время по таймеру.

        al_clear_to_color(al_map_rgb(250, 250, 250));
        // здесь лучше очищать "видимый" буфер, чтобы не отображались картинки, отрисованные в предыдущие моменты времени (зивисит от настроек драйвера на данном компьютере, вообще)
        // по этой же причине волны лучше отрисовывать не по одной, а пачками.

        delta_num = 0;
        // здесь будет храниться приращение количества волн в данном цикле

        draw_static_elements(display, f, d, ss);

        for(i = 0; i < num; i++){
            // будем пробегаться по массиву всех источников и смотреть, попадает ли какой-нибудь в радиус действия в течение ближайшего временного шага
            // увы, без двойного цикла тут не обойтись!
            // даже тройного! надо же по всем точкам волны еще просчитать!

            // итак, идея - рассмотреть не все точки волнового фронта... а сферический слой сразу!!!
            // иначе - слишком много проблем с повторным учетом волн (если все точки фронта рассматривать по отдельности)

            if(is_empty_queue(ws)){
                break;
            }

            // здесь же будем и эволюцию во времени просчитывать, очень удобно, так как очередь
            wave * w = dequeue(ws);
            // "текущая" волна. Извлекаем из очереди "верхний элемент"


            // если время испускания волны больше, чем текущее (то есть, формально, волна еще не испущена, то сразу переходим к следующей, а эту не трогаем)
            if(w->t0 > t){
                enqueue(ws, w);
                continue;
            }

            // вот здесь выкидываем волны, ушедшие от источника слишком далеко, за пределы поля (они и так не учтутся из-за направления, но зачем их лишний раз считать)
            // правда тогда вопрос с утилизацией месте=а в массиве! мб очередь сунуть? да! точно! стек не прокатит, а очередь будет в самый раз. И если необходимо, перепишем ее на динамическом массиве. См выше еще комментарий.

            // реализуем самый простой и не сильно влияющий на производительность способ проверки волны на выход за пределы поля. Так проще, чем все координаты волнового фронта просчитывать. И, скорее всего, быстрее (по крайней мере, не сильно медленнее :) ).

            w->r += r_step;
            // инкрементируем радиус

            w->ampl = w->ampl * ( 1 - r_step / w->r ) * exp_attenuation;

            if(w->ampl < MIN_AMPL || w->r * w->r > FIELD_SIZE_X * FIELD_SIZE_X + FIELD_SIZE_Y * FIELD_SIZE_Y){
                // то есть удаляем волны амплитуды, меньшей минимально рассматриваемой, а также вышедшие за пределы экрана :)
                destroy_wave(w);
                delta_num--;
                continue;
                // пропускаем итерацию в этом случае и продолжаем дальше
            }

            // бежим по всем "источникам"

            for(j = 0; j < ss->n; j++){
                s = ss->SOURCES[j];
                // текущий источник
                scal = w->n_x * (s->pos_x - w->center_x) + w->n_y * (s->pos_y - w->center_y);
                // так как пи - угловой размер волны, по дефолту
                // scal - скалярное произведение вектора волны на вектор "к источнику". Для определения, "с той ли" стороны от центра волны располагается источник

                // благодаря строгому неравенству только что отраженные волны не учтутся снова! беллисимо!
                if(check_is_near(w->center_x, w->center_y, s->pos_x, s->pos_y, w->r, r_step / 2) && scal >= 0){
                    delta_num++;
                    reflect_wave(ws, w, s, t);
                }
                // по отраженным волнам тоже потом пробежимся, понятно :)
                //
                // исходную волну, если она не удалилась выше, тоже необходимо поместить в очередь

            }

            enqueue(ws, w);
            draw_wave(display, w);
            //
                // для экономии ресурсов только что отраженную волну можно не рисовать. Все равно радиус 0! следовательно, совпадает с источником ( = препятствием :) )

            // вот! даже в два цикла все уложили! отлично!
        }


        t += TIME_STEP;
        // инкрементируем время только тогда, когда уже просчитали все волны с меньшим временем!

        num += delta_num;

        // если вдрг волны "кончились", то останавливаем работу и ждем закрытия программы
        if(num <= 0){
            al_destroy_timer(timer);
            // удаляем таймер, чтобы он нам не создавал лишних событий
            //al_flush_event_queue(event_queue);
            // очищаем очередь событий
        }

        // все! теперь, когда все просчитали, смотрим, не словилось ли событие
        // по определению, данная функция ждет, пока в очереди чего-либо не появится

        al_wait_for_event(event_queue, &event);

        if(event.type == ALLEGRO_EVENT_DISPLAY_CLOSE)
            break;
        else if(event.type == ALLEGRO_EVENT_TIMER){
            // важно!!! по-дефолту, алегро рисует на переднем плане то, что было дано позже! именно поэтому у нас некоторое время и отображалось только поле с источниками, без волн :_)
            al_flip_display();
            // помним, что flip_display сбивает все настройки
            // когда наступает время, отрисовываем все изменения
        }

        // выход по нажатию крестика на окне

        al_flush_event_queue(event_queue);
        // очищаем очередь событий на случай, если вдруг за время подсчета набежало несколько таймеров

    }
    if(timer != NULL)
        al_destroy_timer(timer);

    al_destroy_display(display);
    al_destroy_event_queue(event_queue);
    // все уничтожаем, как только вышли из цикла пересчета

    return 0;

}



// функция инициализации окна
ALLEGRO_DISPLAY * init_window(){

    ALLEGRO_DISPLAY * display = NULL;

    // содаем объект типа окно и выполняем все проверки

    if(!al_init()) {
       fprintf(stderr, "Ошибка при инициализации Аллегро!!\n");
       return NULL;
    }

    al_set_new_display_flags(ALLEGRO_WINDOWED | ALLEGRO_RESIZABLE);
    // устанавливаем параметры окна. важно объявить их уже после инициализации интерфейса аллего, но еще до создания дисплея
    al_set_new_window_position(300, 100);


    display = al_create_display(FIELD_SIZE_X + 2 * OFFSET_X, FIELD_SIZE_Y + 2 * OFFSET_Y);

    al_set_window_title(display, "Волны, волны, волны...");

    if(!display) {
       fprintf(stderr, "Ошибка при создании окна!\n");
       return NULL;
    }

    // инициализируем подгрузку примитивов (готовых геометрических фигур)

    if(!al_init_primitives_addon()){
        fprintf(stderr, "Ошибка при инициализации дополнений для примитивов!\n");
        return NULL;
    }

    return display;

}


// функция прорисовки статических элементов. Нужна отдельно, так как flip_display все сбивает
int draw_static_elements(ALLEGRO_DISPLAY * display, field * f, detector * d, sources * ss){

    al_clear_to_color(al_map_rgb(250,250,250));
    // выбираем цвет окна

    // рисуем поле (прямоугольник, чтобы покрасивше)

    ALLEGRO_COLOR border_color = al_map_rgb(10, 10, 10);

    al_draw_rounded_rectangle(OFFSET_X, OFFSET_Y, OFFSET_X + FIELD_SIZE_X, OFFSET_Y + FIELD_SIZE_Y, 15, 15, border_color, 3);


    // рисуем источники (ну, вернее, препятствия :) )

    int i;

    if(ss == NULL || ss->n == 0)
        return -1;

    source * s = NULL;


    ALLEGRO_COLOR source_color = al_map_rgb(0, 0, 100);

    for(i = 0; i < ss->n; i++){
        s = ss->SOURCES[i];
        al_draw_filled_circle(s->pos_x, s->pos_y, SOURCE_SIZE / 2, source_color);
    }


    // рисуем детектор

    ALLEGRO_COLOR detector_color = al_map_rgb(150, 0, 150);

    al_draw_line(d->pos_x + OFFSET_X, 5 + OFFSET_Y, d->pos_x + d->size + OFFSET_X, 5 + OFFSET_Y, detector_color, 10);

    // в месте нахождения каждого из датчиков ставим точку (кружок)

    double r = d->size / d->N / 2;

    for(i = 0; i < d->N; i++){
        al_draw_filled_circle(d->pos_x + OFFSET_X + i * 2 * r + r, 5 + OFFSET_Y, r, al_map_rgb(0, 0, 0));
    }


    return 0;

    //al_flip_display();
    // обновляем то, что на экране (allegro имеет двухбуферную систему вывода.)
    // данная функция выводит то, что было расчитано (второй буфер) на экран, вемсто того, что там было до этого (первый буфер)
    // перед каждм обновлением (flip_display) придется заново заливку устанавливать, увы! так все работает! по крайней мере, я еще до другого варианта не добрался

}

#endif
