#ifndef __TYPES_H__

#define __TYPES_H__


/* ********************* Структуры и типы ****************************** */


// детектор
typedef struct _detector{
    int N;
    // число датчиков
    double size;
    // ширина детектора
    double pos_x;
    // координата левого конца детектора, игрек = нулю, по построению (т е меньшая из координат)
} detector;

// она теперь и не нужна, как таковая!
// исследуемая среда
typedef struct _field{
    //double lim_x;
    //double lim_y;
    detector * d;
    // луше хранить детектор вместе
} field;


// лучи сигналов
typedef struct _line{
    double b;
    double a;
    double phase;
    // фаза луча, арвносильно (условные единицы), его временная задержка
    // y = - сtg a * x + b, y - от детектора, то есть больше 0 в рассматриваемой области
    // удобнее угол наклона, чем коэффициент, чтобы: 1) относительно равномерно инкрементировать, меньше ошибки, то есть 2) чтобы с бесконечностями не работать, и все лучи простраивать
} line;


typedef struct _wave{
    double center_x;
    double center_y;
    double t0;
    // структура сферической двумерной волны, задается положением центра и моментом испускания

    // плюс, чтобы меньше было пересчитатывать, добавим растояние от центра в данный момент времени
    double r;
    double ampl;
    // амплитуда колебаний

    double n_x;
    double n_y;
    // то есть "вектор номрали"

    // плоскость, от которой ораспространяется волна (угловой разсер - 180 град, т е)
    // нет! так двойственность возникает! лучше вектор указывать (заодно и будет проще потом на произваольный угловой размер обобщить)
} wave;

// источники света
typedef struct _source{
    double pos_x;
    double pos_y;
    //double t;
    // время срабытывания

    field * f;
    // поле, к которому относится источник. Тоже мб весьма себе полезно и логично оставить его и здесь
} source;


typedef struct _sources{
    source ** SOURCES;
    int n;
    // структура аналогична предыдущей
} sources;





// Очередь (волн). Просто удобное средство их добавлять и обходить
// Единственное, нужно их количесвто хранить, чтобы цикл бесконечный получить. А мб в этом и фишка?)
// Риал тайм эмуляция, блина! точно! и тогда все вообще прям красиво получится!!!
// и, главное, из=за самого опрееления очереди, принцип причинности не нарушится!

typedef wave * queueT;
// чтобы просто потм было менять тип данных в очереди

typedef struct qNode{
    struct qNode * next;
    queueT data;
} QNODE;

typedef struct queue {
    QNODE * head;
    QNODE * tail;
} QUEUE;

#endif
