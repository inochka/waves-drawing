 /*
        phi0 = atan(w->n_y / w->n_x);
        // надо же как-то по полуокружности пробежаться! :)

        phi = phi0 - PI / 2;
        // удобно в радианах, да и си под них "заточен"
        // лучше для машинной точности около нуля крутиться, чем далеко от него отходить

        // понятно, шаг по углу и временной шаг (критерий "близости" надо еще немного хоть согласовать), чтобы все ок было
        // точно! а лучше даже сделать угловой шаг динамическим, то есть зависящим от "радиуса обхода"!
        // так и сделаем!

        a = SPEED * TIME_STEP;
        // ребро "квадрата проверки"

        step = a / w->r;

        // малые углы. И нахлест небольшой сделали на всякий случай, чтобы проблем не было на границах
        // но не слишком большой, чтобы не было повторных учетов одного отражения
        // а хотя.. чтобы не было повторных отражений, нужно какой-нибудь флаг на источнике при расчете данной волны поставить. Да! это самый лучший вариант
        // а хотя... это же весьма себе маловероятное событие! поэтому... пофиг, наверное :)

        // 2, чтобы не было полного нахлеста
        // плюс надо сделать, чтобы не было отражений от исчтчников сзади волны (почти что терория ФРЕНЕЛЯ получатеся :))) )

        // а может, не париться и замостить лучше квадратиками? да! при малых шагах это будет идеально просто! и проблем с повторным учетом не будет
        //
        // но проблема в том, что этот квадратик повернут "по-левому"!
        // поэтому, наверное, лучше внутри каждой волны создать обновляемый в каждый момент времени массив источников, от который в данный момент времени отражение уже произошло

        // но снова проблемы с предыдущим моментом времени... а может..
        // СРАЗУ ВЕСЬ СФЕРИЧЕСКИЙ СЛОЙ ПРОВЕРЯТЬ?????????
        // и от источников, которые в него попали, отражать! и тогда ни шага никакого не нужно, ничего! и погрешность меньшеЙ отлично! это прекрасная идея :)


        for(k = 0; k < step; k++){
            phi += step;
            x = w->center_x + w->r * cos(phi);
            y = w->center_y + w->r * sin(phi);

            for(j = 0; j < ss->n; j++){

            }
        }
        */
